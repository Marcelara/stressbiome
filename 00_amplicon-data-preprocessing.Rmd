---
title: "NGS_data_preprocessing"
author: "Marcela Aragon"
date: "3/1/2024"
output: html_document
---

This script will deal with importing tables produced by the DADA2/Ernakovich pipeline into a phyloseq object, plus the basic pre-processing following this tutorial: https://benjjneb.github.io/dada2/tutorial.html 

#Loading packages 

```{r load libraries and general setup}

#Load libraries

library(phyloseq)
library(Biostrings)
library(ggplot2)
library(dplyr)
library(tidyr)
library(ape)
library(tibble)
library(readxl)
library(decontam)
library(viridis)
library(vegan)
library(GGally)
library(microbiome)
library(metagMisc)
library(varhandle)

#Set plots theme
ggplot2::theme_set(theme_bw())

```


# 16S

## Making phyloseq object  

I recommend following these tutorial if you are new to phyloseq: https://www.gdc-docs.ethz.ch/MDA/handouts/MDA20_PhyloseqFormation_Mahendra_Mariadassou.pdf 


### Loading data

#### OTU table

```{r 16S otu table}

#1. Load OTU table
otu <- otu_table(object = read.table(file = "./amplicon_data/16S_2/seqtab_final.txt", 
                                              header = TRUE,
                                              row.names = 1, # first column has row names (ASV names)
                                              check.names = FALSE), # prevents "X" to be added to column names
                                              taxa_are_rows = TRUE)

#removing rest of sample names so it matches Harvest ID
x <- sample_names(otu)
y <- gsub(".*\\.", "", x) #removing everything that is before the last point https://statisticsglobe.com/r-remove-characters-before-or-after-point-in-string 

#replace
sample_names(otu) <- y

#check
head(otu)

#clean 
rm(x, y)

```

#### Taxonomy table

```{r 16S taxonomy table}

#2. Load taxonomy table
taxtab <-read.table(file = "./amplicon_data/16S_2/taxonomy.tsv", 
                               header = TRUE,
                               sep = "\t",
                               row.names = 1, # first column has row names (ASV names)
                               check.names = FALSE) # prevents "X" to be added to column names, such as X49_16S

# adjusts number and name of columns
taxtab<- separate(data = taxtab,
                          col = Taxon,
                          into =c("Kingdom", 
                                       "Phylum", 
                                       "Class", 
                                       "Order", 
                                       "Family",
                                       "Genus", 
                                       "Species"),
                               sep = ";")

# saves taxtable as phyloseq object
taxtab<-tax_table(object = as.matrix(taxtab))

```

#### Sequences

```{r 16s refseq}

#3. Load sequences 
refseq <- refseq(physeq = Biostrings::readDNAStringSet(filepath = "./amplicon_data/16s_2/repset.fasta", use.names = TRUE)) 

head(taxa_names(refseq))

```

#### Phylogenetic tree

```{r 16s phylotree}

#4. Load phylogenetic tree 

tree <- phy_tree(read.tree("./amplicon_data/16s_2/tree.nwk"))
tree

```

#### Metadata

```{r metadata}
#5. Load metadata 
metadata_full <- read.table(file = "./amplicon_data/16s_2/Mapping_file_16S_Family_experiment.txt", 
                                                  header = TRUE,
                                                  sep = "\t",
                                                  row.names = 1, # first column has row names (ASV names)
                                                  check.names = FALSE)

#keeping only samples from PSF experiment
colnames(metadata_full)
str(metadata_full)
metadata_full$Sp_speed <- as.factor(metadata_full$Sp_speed)
metadata_full$sample_type <- as.factor(metadata_full$sample_type)
metadata_full$Harvest_ID <- as.factor(metadata_full$Harvest_ID)
levels(metadata_full$Sp_speed) #I need BraOle, Blank, S1, and M1 (S9 Kimmeridge for now not)
levels(metadata_full$sample_type) #rhizoplane and Blank

metadata_sel <- metadata_full %>% 
            filter(Sp_speed %in% c("BraOle", "S1", "Blank", "M1"),
                   sample_type %in% c("rhizoplane", "Blank"),     #remove topsoil 
                   !Harvest_ID %in% c("Blank_top1", "Blank_top2"))%>% #remove leftover blanks 
                   droplevels()

#remove non-informative columns from Family Experiment
metadata_sel <- metadata_sel[ , ! names(metadata_sel) %in% 
                                  c("Block_row_column",
                                     "Rows", "Columns", 
                                    "plant_family", "Lineage", "Tribe", "Guest", 
                                    "Rainbow", "Flowering", "Rainbow.batch", "Missing",
                                    "Plate_postion", "Plate_row", "Plate_column", "Plate_name",
                                    "GQ_submission_order", "Plate_place")]

levels(metadata_sel$Sp_speed) #ok
          
```

Adding experimental information to metadata

```{r 16s fixing metadata}

#Add more metadata from experiment 
phyto <- read_excel("./plant_data/CleanData_PSF.xlsx", sheet="cond_phytohormones",
                    col_names = TRUE) 

insects <- read_excel("./plant_data/CleanData_PSF.xlsx", sheet="cond_real_insects",
                    col_names = TRUE) 
#check colnames
colnames(phyto)
colnames(insects)
colnames(phyto)[3] <- 'ID_experiment' #change name so it matches

#make it to factor
phyto[c(1:12, 14:18, 20:21)] <- lapply(phyto[c(1:12, 14:18, 20:21)], factor)
str(phyto)
insects[c(1:12, 15:20, 22:23)] <- lapply(insects[c(1:12, 15:20, 22:23)], factor)

#make new column in both
phyto <- phyto %>% 
           mutate(Harvest_ID = 
                 case_when(
                    Experiment == "cond_phytohormones" ~ Family_Harvest_ID))

insects <- insects %>% 
           mutate(Harvest_ID =
                    case_when(
                    Experiment == "cond_real_insects"~ ID_experiment))

#adding _ch so it matches sample_id from microbiome data
insects$Harvest_ID = paste(insects$Harvest_ID,"ch", sep = "_")

#merge
metadata.cond <- bind_rows(phyto, insects)

#remove & re-arrange columns
metadata.cond <- metadata.cond[ , ! names(metadata.cond) %in% 
                                  c("Family_Species_code", "Family_Harvest_ID",
                                    "Rainbow", "soil")]  
#merge with ps metadata 
metadata.merged <- dplyr::left_join(metadata_sel, metadata.cond, by="Harvest_ID") #join Haris & Family metadata

#add rownames
row.names(metadata.merged) <- paste(metadata.merged$Harvest_ID,"16S", sep = "_")
metadata.merged$root_weight <- as.numeric(metadata.merged$root_weight)
metadata.merged$Stress <- as.factor(metadata.merged$Stress)

#Add 'Experiment' to blanks 
metadata.merged$Experiment[metadata.merged$Harvest_ID == 'Blank_S1'] <- 'cond_phytohormones'
metadata.merged$Experiment[metadata.merged$Harvest_ID == 'Blank_CH'] <- 'cond_real_insects'

#Add EPG to Experiment for M1
x <- addNA(metadata.merged$Experiment) #add NA's
metadata.merged$Experiment <- x #replace
metadata.merged$Experiment <- as.character(metadata.merged$Experiment) #make it a character
metadata.merged$Experiment[is.na(metadata.merged$Experiment)] <- 'EPG' #change it
metadata.merged$Experiment <- as.factor(metadata.merged$Experiment)

#Add whether is a true sample or a blank sample
metadata.merged <- metadata.merged %>% 
                   mutate(sample_or_blank = 
                            case_when(
                              Stress == "Blank" ~ "blank",
                              TRUE ~ "sample"))
#relocate
metadata <- metadata.merged %>% 
                  relocate(Target, Harvest_ID, Experiment, treated_with, plant_pathway_induced,
                           herbivore, herbivory) %>%
                  relocate(root_weight, .after=shoot_biomass) %>%
                  relocate(where(is.numeric), .after=Stress) %>%
                  relocate(ID_experiment, .after=Plate)  #this is the plant ID from Haris' data

#Include plant_pathway induced for EPG as well 
metadata  <- metadata %>%
            mutate(plant_pathway_induced=case_when(
             (Experiment == "EPG" & Stress == "Control") ~ "Control",
             (Experiment == "EPG" & Stress == "MeJA") ~ "JA",
             (Experiment == "EPG" & Stress == "SA") ~ "SA",
             .default=as.character(plant_pathway_induced))) #keeps the rest as it is

#Finally make it a sample_data object for phyloseq 
metadata<- sample_data(metadata)
head(metadata)

#clean
rm(metadata_full, metadata.cond,
   metadata.merged, phyto, insects, metadata_sel, x)

```

#### Final ps object

Now, make phyloseq object  

```{r 16S making ps object}

#Merge to create phyloseq 
ps_16S <- merge_phyloseq(metadata, otu, taxtab, refseq, tree)

# change names from ASV to bASV, so they can be distinguished from fungal ASVs
taxa_names(ps_16S)<- paste("b", taxa_names(ps_16S), sep = "")

#add total number of reads 
ps_16S@sam_data$total_reads <- sample_sums(ps_16S)
hist(ps_16S@sam_data$total_reads) #some with less than 50,000, some with more than 250,000

View(sample_data(ps_16S)) 

ps_16S_raw <- ps_16S

#save ps_16S
#save(ps_16S_raw, file = "./amplicon_data/Phyloseq_objects/ps_16S_raw.RData")

#clean to not have it twice
rm(tree, otu, taxtab, refseq, metadata)

```

Quick visualization
```{r}

ps_16S <- ps_16S_raw #save to compare 

#quick check on the number of reads 
sums <- sample_sums(ps_16S)
sums[order(sums)]#0,6,60! (something went wrong)

# Lowest total count:
min(sums)

# Sample with lowest counts:
names(sums[order(sums)][1]) #123_ch

#let's remove it so there's no problems after
#ps_16S <- subset_samples(ps_16S, Harvest_ID != "123_ch")
#prune_taxa(taxa_sums(ps_16S ) >0, ps_16S)

```

## Remove contaminants 

### Decontam package Exploration

Following: https://benjjneb.github.io/decontam/vignettes/decontam_intro.html, https://mcic-osu.github.io/2020-12-microbiomics-workshop/08-postASV-analysis.html & parts of Pedro's script

The decontam package tests whether abundance of a certain taxa is not associated with DNA concentration. Because DNA concentration measurements are not very accurate and we want to remove possible contaminants we use a relaxed p value following the Microbiomics Workshop

#### Both

```{r}

#makes new column with 'TRUE' just for blanks
ps_16S@sam_data$is.neg <- ps_16S@sam_data$Stress=="Blank" 

#Combining both frequency and prevalence approaches
contamdf.both <- isContaminant(ps_16S,
                               method="combined",
                               neg="is.neg",
                               batch="Experiment",
                               threshold=0.2,
                               conc="Amplicon_concentation_ngul")

table(contamdf.both$contaminant) #379 ASVs contaminants     

## Check which taxa are contaminants:
ps_contam <- prune_taxa(contamdf.both$contaminant, ps_16S)
tax_table(ps_contam) #lots of most abundant ASVs
sort(table(tax_table(ps_contam)[, 2]), decreasing=TRUE) 

#plot frequency of contaminant ASVs vs DNA concentration
plot_frequency(ps_16S, taxa_names(ps_16S)[sample(which(contamdf.both$contaminant),40)],
               conc="Amplicon_concentation_ngul")+
               xlab("DNA concentration (ngul)") #looks good

#Which samples have the highest abundance of contaminants?
p_cont <- plot_bar(ps_contam, fill="Phylum")

p_cont + facet_wrap(~Experiment, nrow=1, scales="free_x") +
  ggtitle("samples with the highest abundance of contaminants by both (379 ASVs)")

ggsave("Bac.raw_both-contam_BySample.png", path = "./Plots/00_amplicon_preprocessing/",
         width = 40, height = 20 , units = "in", dpi=300, scale=0.5)

#What proportion of reads were removed as contaminants?
ps_noncontam <- prune_taxa(!contamdf.both$contaminant, ps_16S)

pre <- sum(sample_sums(ps_16S))
post <- sum(sample_sums(ps_noncontam))

((pre-post)/pre)*100 #only 0.7%

#names of ASVs
contaminants.both <- rownames(subset(contamdf.both, contaminant%in%c("TRUE")))

```  

* Same trend as for frequency and prevalence, but this seems a middle point


#### Final step

Use both prevalence and frequency for 16S
```{r}    

ps_16S_decontam <- ps_16S

#Now finally make new ps without contaminants 

#clean physeq object by removing contaminant OTUS
ps_16S <- prune_taxa(!taxa_names(ps_16S) %in% contaminants.both, ps_16S) 

#remove those ASVs with now 0 reads 
prune_taxa(taxa_sums(ps_16S) >0, ps_16S)

#plot final ps to check if the condition is not matched
set.seed(100)
plot_frequency(seqtab = ps_16S, 
               taxa = sample(taxa_names(ps_16S),40),
               conc="Amplicon_concentation_ngul")+
    ggtitle("Real ASVs") #looks goodish

#check number of reads 
plot(sort(sample_sums(ps_16S))) #still some samples with very few reads and lots of reads

#make new column with this information
ps_16S@sam_data$libsize_after_decontam <- sample_sums(ps_16S)

sort(ps_16S@sam_data$libsize_after_decontam) #3 samples with very low reads 

#clean
rm(contamdf.freq, contamdf.both, contamdf.prev, pre, post, sums,
     p_cont, ps_contam, ps_noncontam, contaminants.prev, contaminants.freq, contaminants.both)

```


## Filtering 

### Non-bacterial & plastid ASVs
```{r}

ps_16S_plastid <- ps_16S #save to compare 

# see contamination of non-bacterial ASVs
table(tax_table(ps_16S)[, 1]) #there's Archea & unassigned

# keeps only Bacteria ASVs
ps_16S <- subset_taxa(ps_16S, Kingdom=="d__Bacteria")
ps_16S #64,238 taxa 

#First, visualize plastid reads

#chloroplast
#p_Chloro <- plot_bar(subset_taxa(ps_16S, Order==" o__Chloroplast"), fill="Species")
#p_Chloro + facet_wrap(~Experiment, nrow=1, scales="free_x") +
#  ggtitle("Chloroplast contamination")

#ggsave("Bac.Chloroplast-contam.png", path = "./Plots/00_amplicon_preprocessing/",
#         width = 40, height = 20 , units = "in", dpi=300, scale=0.5)

#mitochondria
#p_Mito <- plot_bar(subset_taxa(ps_16S, Family==" f__Mitochondria"), fill="Species")
#p_Mito + facet_wrap(~Experiment, nrow=1, scales="free_x") +
#  ggtitle("Mitochondria contamination")

#ggsave("Bac.Mitochondria-contam.png", path = "./Plots/00_amplicon_preprocessing/",
#         width = 40, height = 20 , units = "in", dpi=300, scale=0.5)

#clean 
#rm(p_Chloro, p_Mito)

```
* Phyto experiment has overall more plastid contamination than insect experiment (or maybe the same as they have less number of reads)
*EPG experiment has a lot of plastid reads

Now, remove plastid reads

```{r}

#define plastid, mitochondria and host plant contamination ps objects
Mitochondria_ps<- subset_taxa(ps_16S, Family==" f__Mitochondria" | Family == "Mitochondria") #there's a 
Chloroplast_ps <-subset_taxa(ps_16S, Order == " o__Chloroplast" | Order == "Chloroplast") #space between " o_..." 

#host_plant_ps<-merge_phyloseq(Chloroplast_ps, Mitochondria_ps) #not working because of phy_tree

#removing phy_tree
Mitochondria_ps@phy_tree <- NULL
Chloroplast_ps@phy_tree <- NULL

#merge
host_plant_ps<-merge_phyloseq(Chloroplast_ps, Mitochondria_ps)

#quick histogram showing plant DNA contamination
hist(sample_sums(host_plant_ps)/sample_sums(ps_16S)*100, breaks = 100) #from 0 to 66% host DNA contamination contamination

# define host plant 16S contamination as metadata
ps_16S@sam_data$Mitochondria_reads<-sample_sums(Mitochondria_ps)
ps_16S@sam_data$Chloroplast_reads<-sample_sums(Chloroplast_ps)
ps_16S@sam_data$Plastid_reads<-sample_sums(host_plant_ps) #both
ps_16S@sam_data$Plastid_contamination_pct<-sample_sums(host_plant_ps)/sample_sums(ps_16S)*100

#Remove plastid ASVs
# prune_taxa only works with those to keep not to "keep out", thus a little trick is needed
# to make a new vector: https://github.com/joey711/phyloseq/issues/652

plastid_taxa <- taxa_names(host_plant_ps)
all_taxa <- taxa_names(ps_16S)
taxa_to_keep <- all_taxa[!all_taxa %in% plastid_taxa] 

ps_16S <- prune_taxa(taxa_to_keep, ps_16S)

#compare 
ps_16S_plastid #old ps
ps_16S #new ps filtered without plastid reads (-354 ASVs) 61,949 ASVs

mean(sample_sums(ps_16S))/mean(sample_sums(ps_16S_plastid)) #also in number of reads (~20% less) = 79% of reads kept

#clean
rm(Mitochondria_ps, Chloroplast_ps, host_plant_ps)

```

* On average low host DNA contamination (16%), however for some samples host DNA contamination was more than 50% of the reads 


### By sample reads & non-informative ASVs

First, by full ps
```{r}

ps_16S_filtering <- ps_16S #make another one so you can compare

#quick check on the number of reads 
sums <- sample_sums(ps_16S)
sums[order(sums)]

#add number of reads after plastid
ps_16S@sam_data$libsize_after_plastid<-sample_sums(ps_16S)

#see how many reads
median <- median(ps_16S@sam_data$libsize_after_plastid) #79,162
mean <- mean(ps_16S@sam_data$libsize_after_plastid) #85,408.93
stdev <- sd(ps_16S@sam_data$libsize_after_plastid) #43,618.86

#which will be the maximum of reads allowed if we keep mean +/- 2 stdev?
mean + 2*stdev #172,646.7 ~ 173,000
mean - 2*stdev #-1,828 

#for now, just remove samples with low number of reads, removing those with less than 10,000 reads
ps_16S <- subset_samples(ps_16S, libsize_after_plastid > 10000) 

#remove blanks
ps_16S <- subset_samples(ps_16S, sample_or_blank != "blank") 

#remove ASVs with low-length sequences
#check final sequence length. 16S sequences smaller than 380bp should be discarded
summary(ps_16S@refseq@ranges@width) 
hist(as.data.frame(refseq(ps_16S)@ranges)$width, breaks = 50)

#remove the ones smaller than 380bp
ps_16S<- prune_taxa(taxa = as.data.frame(refseq(ps_16S)@ranges)$width>380,
                      x = ps_16S) #431 ASVs removed

#remove those ASVs with now 0 reads 
prune_taxa(taxa_sums(ps_16S) >0, ps_16S) #48,625 taxa

#let's see how many sequences were kept after this filtering
sum(sample_sums(ps_16S))/sum(sample_sums(ps_16S_filtering))*100 # 99.41% of sequences kept

#add column to sample_data
ps_16S@sam_data$libsize_after_filtering <- sample_sums(ps_16S)

#add how many reads were kept at the end
ps_16S@sam_data$pct_reads_kept <- ((ps_16S@sam_data$libsize_after_filtering/ps_16S@sam_data$total_reads)*100)

#get summary info per experiment
reads_summary <- ps_16S@sam_data %>% 
                 data.frame() %>% 
                 group_by(Experiment)%>%
                 summarise(reads_per_sample = mean(libsize_after_filtering),
                           stdev=sd(libsize_after_filtering),
                           reads_kept_perc= mean(pct_reads_kept),
                           stdev_perc=sd(pct_reads_kept))

#get summary info per treatment & experiment
reads_summary.t <- ps_16S@sam_data %>% 
                    data.frame() %>% 
                    group_by(Experiment, plant_pathway_induced)%>%
                    summarise(reads_per_sample = mean(libsize_after_filtering),
                           stdev=sd(libsize_after_filtering),
                           reads_kept_perc= mean(pct_reads_kept),
                           stdev_perc=sd(pct_reads_kept),
                           n=n())


#check
hist(ps_16S@sam_data$pct_reads_kept)

```

Now, save a split ps by experiment
```{r }

#as they come from independent experiments, separate them to filter them independently
ps_16S_split <- phyloseq_sep_variable(ps_16S, variable=c("Experiment"), drop_zeroes = T)


ps_Insects <- phyloseq_sep_variable(ps_16S_split$cond_real_insects, variable=c("plant_pathway_induced"), drop_zeroes = T)


#check how many ASVs per experiment
nASVs <- lapply(ps_16S_split, function(ps){ntaxa(ps)})

#plot histograms
lapply(ps_16S_split, function(ps){
  hist(ps@sam_data$pct_reads_kept)})

#save it
save(ps_16S_split, file = "./amplicon_data/Phyloseq_objects/ps_16S_split.RData")

```


Checking filtering of full ps object 
```{r}
#make it a df to plot it 
df_16S <-data.frame(sample_data(ps_16S))
order_harvestID <- df_16S$Harvest_ID

#make Harvest ID a factor to have a better plot
df_16S$Harvest_ID <- factor(df_16S$Harvest_ID, levels=order_harvestID)

#see it 
ggplot(df_16S, aes(pct_reads_kept, Harvest_ID, label = Harvest_ID)) +    
       geom_point(aes(colour = Experiment)) +
       geom_text(aes(label = Harvest_ID), hjust = - 0.5)+
       facet_wrap(~Experiment, scales="free_x")

ggsave("Bac.percentage_reads_kept.png", path = "./Plots/00_amplicon_preprocessing/",
         width = 40, height = 20 , units = "in", dpi=300, scale=0.3)

#see how it changes with paired plot

#make paired plot
df_reads <- subset(df_16S, 
                   select= c("Harvest_ID", "Experiment", "total_reads", "libsize_after_decontam", "libsize_after_plastid", "libsize_after_filtering"))

df_reads_long <- df_reads %>% 
                 pivot_longer(!c(Harvest_ID,Experiment), names_to = "Steps",
                         values_to = "number_of_reads")

df_reads_long$Steps <- factor(df_reads_long$Steps, 
                   levels= c("total_reads", "libsize_after_decontam",
                             "libsize_after_plastid", "libsize_after_filtering"))

ggplot(df_reads_long, aes(x=Steps, y=number_of_reads))+
  geom_boxplot(aes(fill=Steps), alpha=0.2)+
  geom_line(aes(group = Harvest_ID)) + 
  geom_point(size = 2)+  
  geom_label(aes(label= Harvest_ID), size=2.5)+
  facet_wrap(~Experiment)

ggsave("Bac.summary_reads-after-filteringsteps.png", path = "./Plots/00_amplicon_preprocessing/",
         width = 40, height = 20 , units = "in", dpi=300, scale=0.3)

#clean
rm(df_16S, df_reads, all_taxa, filter,taxa_to_keep, sums,
   plastid_taxa, order_harvestID, df_reads_long, mean, median, stdev)

```


## New ps
```{r}

#last check of filtering steps

ps_16S_raw #64,698
ps_16S_decontam #64,698
ps_16S_plastid #64,319
ps_16S_filtering #61,949
ps_16S #61,295

#save ps object 
save(ps_16S, file = "./amplicon_data/Phyloseq_objects/ps_16S.RData")

#clean
rm.all.but(keep=c("ps_16S", "ps_16S_split", "ps_Phyto", "ps_Insects"), keep_functions = TRUE)

```

# ITS

## Making phyloseq object  

### Loading data

#### OTU table
```{r}

#1. Load OTU table
otu <- otu_table(object = read.table(file = "./amplicon_data/ITS_2/seqtab_final.txt", 
                                              header = TRUE,
                                              row.names = 1, # first column has row names (ASV names)
                                              check.names = FALSE), # prevents "X" to be added to column names
                                              taxa_are_rows = TRUE)

#removing rest of sample names so it matches Harvest ID
x <- sample_names(otu)
y <- gsub(".*\\.", "", x) #removing everything that is before the last point https://statisticsglobe.com/r-remove-characters-before-or-after-point-in-string 

#replace
sample_names(otu) <- y

#clean 
rm(x, y)

#check
otu #now correct sample names 

```

#### Taxonomy table

```{r}
#2. Load taxonomy table
taxtab <-read.table(file = "./amplicon_data/ITS_2/taxonomy.tsv", 
                               header = TRUE,
                               sep = "\t",
                               row.names = 1, # first column has row names (ASV names)
                               check.names = FALSE) # prevents "X" to be added to column names, such as X49_16S

# adjusts number and name of columns
taxtab <- separate(data = taxtab,
                          col = Taxon,
                          into =c("Kingdom", 
                                       "Phylum", 
                                       "Class", 
                                       "Order", 
                                       "Family",
                                       "Genus", 
                                       "Species"),
                               sep = ";")
head(taxtab) #check

# saves taxtable as phyloseq object
taxtab<-tax_table(object = as.matrix(taxtab))

```

The most abundant ASV is classified as NA at Phylum level


#### Sequences

```{r}

#3. Load sequences 
refseq <- refseq(physeq = Biostrings::readDNAStringSet(filepath = "./amplicon_data/ITS_2/repset.fasta",
                                                       use.names = TRUE)) 

#taxa_names(raw_bac_refseq)<-gsub(" .*", "", taxa_names(raw_bac_refseq)) # drops taxonomy from ASV names
head(taxa_names(refseq)) #check
```

#### Phylogenetic tree

```{r}

#4. Load phylogenetic tree 
tree <- phy_tree(read.tree("./amplicon_data/ITS_2/tree.nwk"))


```

#### Metadata

```{r}

#5. Load metadata from Family Experiment (sequencing-sample metadata)
metadata_full <- read.table(file = "./amplicon_data/ITS_2/Mapping_file_ITS_Family_experiment.txt", 
                                                  header = TRUE,
                                                  sep = "\t",
                                                  row.names = 1, # first column has row names (ASV names)
                                                  check.names = FALSE)

#check df 
colnames(metadata_full)
str(metadata_full)
metadata_full$Sp_speed <- as.factor(metadata_full$Sp_speed)
metadata_full$sample_type <- as.factor(metadata_full$sample_type)
metadata_full$Harvest_ID <- as.factor(metadata_full$Harvest_ID)

#keep only samples from PSF experiment
levels(metadata_full$Sp_speed) #I need BraOle (Real herbivory) and S1 (Phytohormones)
levels(metadata_full$sample_type) #I need rhizoplane and Blank

metadata_sel <- metadata_full %>% 
            filter(Sp_speed %in% c("BraOle", "S1", "Blank", "M1"),
                   sample_type %in% c("rhizoplane", "Blank"),     #remove topsoil 
                   !Harvest_ID %in% c("Blank_top1", "Blank_top2")) #remove leftover blanks 

#remove non-informative columns from Family Experiment
metadata_sel <- metadata_sel[ , ! names(metadata_sel) %in% 
                                  c("Block_row_column", "Sp_speed",
                                    "Speed", "Block", "Rows", "Columns", "Plant_species_name",
                                    "plant_family", "Lineage", "Tribe", "Guest", 
                                    "Rainbow", "Flowering", "Rainbow.batch", "Missing",
                                    "Plate_postion", "Plate_row", "Plate_column", "Plate_name",
                                    "GQ_submission_order", "Plate_place", "Shoot_.DryWeight")]
dim(metadata_sel) #much smaller   

```

Now, let's add information from the PSF experiment itself into the metadata to be able to make correlations
```{r}

#Add more metadata from experiment 
phyto <- read_excel("./plant_data/CleanData_PSF.xlsx", sheet="cond_phytohormones",
                    col_names = TRUE) 

insects <- read_excel("./plant_data/CleanData_PSF.xlsx", sheet="cond_real_insects",
                    col_names = TRUE) 
#check colnames
colnames(phyto)
colnames(insects)
colnames(phyto)[3] <- 'ID_experiment' #change name so it matches

#make it factors
phyto[c(1:12, 14:18, 20:21)] <- lapply(phyto[c(1:12, 14:18, 20:21)], factor)
str(phyto)
insects[c(1:12, 15:20, 22:23)] <- lapply(insects[c(1:12, 15:20, 22:23)], factor)

#make new column in both to add the ID number so it matches the microbiome data 
phyto <- phyto %>% 
           mutate(Harvest_ID = 
                 case_when(
                    Experiment == "cond_phytohormones" ~ Family_Harvest_ID))

insects <- insects %>% 
           mutate(Harvest_ID =
                    case_when(
                    Experiment == "cond_real_insects"~ ID_experiment))

#adding _ch so it matches sample_id from microbiome data
insects$Harvest_ID = paste(insects$Harvest_ID,"ch", sep = "_")

#merge
metadata.cond <- bind_rows(phyto, insects)

#remove & re-arrange columns
metadata.cond <- metadata.cond[ , ! names(metadata.cond) %in% 
                                  c("Family_Species_code", "Family_Harvest_ID",
                                    "Rainbow", "soil")]  
#merge with ps metadata 
metadata.merged <- dplyr::left_join(metadata_sel, metadata.cond, by="Harvest_ID") #join microbiome & experimental data

#add rownames
row.names(metadata.merged) <- paste(metadata.merged$Harvest_ID,"ITS", sep = "_")
metadata.merged$root_weight <- as.numeric(metadata.merged$root_weight)
metadata.merged$Stress <- as.factor(metadata.merged$Stress)

#Add 'Experiment' to blanks 
metadata.merged$Experiment[metadata.merged$Harvest_ID == 'Blank_S1'] <- 'cond_phytohormones'
metadata.merged$Experiment[metadata.merged$Harvest_ID == 'Blank_CH'] <- 'cond_real_insects'

#Add EPG to Experiment for M1
x <- addNA(metadata.merged$Experiment) #add NA's
metadata.merged$Experiment <- x #replace
metadata.merged$Experiment <- as.character(metadata.merged$Experiment) #make it a character
metadata.merged$Experiment[is.na(metadata.merged$Experiment)] <- 'EPG' #change it
metadata.merged$Experiment <- as.factor(metadata.merged$Experiment)

metadata.merged$Experiment[metadata.merged$Harvest_ID == 'Blank_M1'] <- 'EPG'

#Add whether is a true sample or a blank sample
metadata.merged <- metadata.merged %>% 
                   mutate(sample_or_blank = 
                            case_when(
                              Stress == "Blank" ~ "blank",
                              TRUE ~ "sample"))
#relocate
metadata <- metadata.merged %>% 
                  relocate(Target, Harvest_ID, Experiment, treated_with, plant_pathway_induced,
                           herbivore, herbivory) %>%
                  relocate(root_weight, .after=shoot_biomass) %>%
                  relocate(where(is.numeric), .after=Stress) %>%
                  relocate(ID_experiment, .after=Plate)  #this is the plant ID from Haris' data

#Include plant_pathway induced for EPG as well 
metadata  <- metadata %>%
            mutate(plant_pathway_induced=case_when(
             (Experiment == "EPG" & Stress == "Control") ~ "Control",
             (Experiment == "EPG" & Stress == "MeJA") ~ "JA",
             (Experiment == "EPG" & Stress == "SA") ~ "SA",
             .default=as.character(plant_pathway_induced))) #keeps the rest as it is

#Finally make it a sample_data object for phyloseq 
metadata<- sample_data(metadata)
head(metadata)

```

#### Final ps object 

Now, make phyloseq object  

```{r}

#Merge to create phyloseq 
ps_ITS <- merge_phyloseq(metadata, otu, taxtab, refseq, tree)

# change names from ASV to fASV, so they can be distinguished from bacterial ASVs
taxa_names(ps_ITS )<- paste("f", taxa_names(ps_ITS), sep = "")

#add total number of reads 
ps_ITS@sam_data$total_reads <- sample_sums(ps_ITS)

#change name to save it
ps_ITS_raw <- ps_ITS

#save ps_ITS_raw
save(ps_ITS_raw, file = "./amplicon_data/Phyloseq_objects/ps_ITS_raw.RData")

#clean
rm.all.but(keep=c("ps_16S", "ps_16S_split", "ps_ITS_raw", "ps_Phyto", "ps_Insects", "ps_ITS"), keep_functions = TRUE)


```


```{r}

#call it back ps_ITS to start filering and keep the 'raw' version untouched
#ps_ITS <- ps_ITS_raw

#quick check on the number of reads 
sums <- sample_sums(ps_ITS)
sums[order(sums)]

# Lowest total count:
min(sums)

# Sample with lowest counts:
names(sums[order(sums)][1]) #makes sense 

```

Looks like all those samples that have very low reads also have low numbers of different ASVs and hence might be an artifact of the sequencing depth. These samples need to be removed. 

More samples from the phytohormone experiments are low on reads compared to real insects.

## Remove contaminants 

Run decontam package and result was losing between 20% and 24% of the reads which seems like a lot, perhaps ITS data is different than 16S where only 0.7% of the reads were lost when using a combination of prevalence and frequency.

Frequency plots also seemed a bit off as these ASVs have a lot of reads but not necessarily extremely more at low DNA concentrations. Therefore, I will skip the decontamination for fungi altogether.

## Filtering 

https://mcic-osu.github.io/2020-12-microbiomics-workshop/08-postASV-analysis.html#Filter_samples

https://joey711.github.io/phyloseq/preprocess.html 

### Non-fungal ASVs
```{r}

#save it to compare
ps_ITS #3,553 taxa

#Add number of reads before filtering (It's the same as 'total_reads')
#ps_ITS@sam_data$libsize_before_filtering <-sample_sums(ps_ITS)

# see contamination of non-fungal ASVs
table(tax_table(ps_ITS)[, 1]) #there's Protista, Rhizaria and Unassigned

# keeps only Fungal ASVs
ps_ITS <- subset_taxa(ps_ITS, Kingdom=="k__Fungi")
ps_ITS #2,825 taxa 

#Add number of reads before filtering
ps_ITS@sam_data$libsize_after_nonFungi <-sample_sums(ps_ITS)

#check
pre <- sum(ps_ITS@sam_data$total_reads)
post <- sum(ps_ITS@sam_data$libsize_after_nonFungi)

((pre-post)/pre)*100 #2.38% reads lost 


```

## Add missing taxonomy
As later on I will split the ps in 3, I need to add now information about missing taxonomy and FunGuild info to avoid running it 3x later on.


```{r}

tax <- as.data.frame(tax_table(ps_ITS))
which(is.na(tax$Phylum)) #286 ASVs are NA at Phylum level

Phylum_NA <- rownames(tax)[which(is.na(tax$Phylum))] #get which ones 

#make a copy
ps_phylum <- ps_ITS 

#add ASV as a column
tax$ASV <- rownames(ps_phylum@tax_table)  
#replace in ps 
tax_table(ps_ITS) <- tax_table(object = as.matrix(tax))

#Now, let's get the sequences
ps_phylum <- subset_taxa(ps_ITS, ASV %in% Phylum_NA) #ok

#Intermezzo: to get only those that are more abundant (ASV1-100)
x <- as.data.frame(Phylum_NA)
number <- separate(x, col=Phylum_NA, into= c("NA", "Number") )

x$Number <- number$Number
str(x) #ok
x$Number <- as.numeric(x$Number)

#Get them in order
x <- x[order(x$Number),]

ASV_sel <- x[c(1:10),] #get top 10 most abundant ones
ASV_sel <- ASV_sel$Phylum_NA

ps_sel <- subset_taxa(ps_phylum, ASV %in% ASV_sel)

#save sequences of the most abundant ASVs (ASV 1-170) to blast them in NCBI 
ps_sel %>%
refseq() %>%
Biostrings::writeXStringSet("./amplicon_data/ITS_phylum_NA_sel.fna",
             append=FALSE,compress=FALSE,
             compression_level=NA, format="fasta")

```

Manually, I blasted the ITS sequencing of the 10 most abundant fungi (below 170), the rest I will leave them with unknown taxonomy.

Taxonomy table was filled to the taxonomic level in which there was a consensus on the top 5 hits with more % of identity and highest E value and a query cover of at least 50%.

```{r}
#Make taxonomy table a df so its easier to sort
tax <- as.data.frame(tax)
colnames <- colnames(tax)

#get names of taxonomy to write exactly the same ones 
unique(tax$Phylum)
sort(unique(tax$Class))
sort(unique(tax$Order))
sort(unique(tax$Family))
sort(unique(tax$Genus))
sort(unique(tax$Species))

#make one vector from each from the blast of NCBI
#adding "NCBI" in the confidence column to trace them back if needed 

#f_ASV1
f_ASV1 <- c("k__Fungi","p__Olpidiomycota","c__Olpidiomycetes","o__Olpidiales","f__Olpidiaceae","g__Olpidium","s__Olpidium_brassicae","NCBI","fASV_1")

#f_ASV27
f_ASV27 <- c("k__Fungi","p__Mortierellomycota","c__Mortierellomycetes","o__Mortierellales","f__Mortierellaceae",NA,NA,"NCBI","fASV_27")

#f_ASV80
f_ASV80 <- c("k__Fungi","p__Mortierellomycota","c__Mortierellomycetes","o__Mortierellales","f__Mortierellaceae",NA,NA,"NCBI","fASV_80")

#f_ASV81
f_ASV81 <- c("k__Fungi","p__Basidiomycota","c__Ustilaginomycetes","o__Ustilaginales",NA,NA,NA,"NCBI","fASV_81")

#f_ASV95
f_ASV95 <- c("k__Fungi","p__Mortierellomycota","c__Mortierellomycetes","o__Mortierellales","f__Mortierellaceae",NA,NA,"NCBI","fASV_95")

#f_ASV110 <- no hit was above 20% of query, therefore discarded 

#f_ASV143 <- no hit was above 20% of query, therefore discarded 

#f_ASV146
f_ASV146 <- c("k__Fungi","p__Ascomycota","c__Dothideomycetes","o__Pleosporales","f__Cucurbitariaceae",NA,NA,"NCBI","fASV_146")

#f_ASV168 <- no hit was above 20% of query, therefore discarded 


#Now, let's replace this taxonomy information in the ps object

#keep it as taxonomy table (matrix)
tax <- tax_table(ps_ITS)

tax[rownames(tax) %in% "fASV_1"] #this is how I get one row from the matrix 

tax[rownames(tax) %in% "fASV_1"] <- f_ASV1  #this is how I can replace for one thing

#check
tax[rownames(tax) %in% "fASV_1"] #works!!

#do the same with the rest
tax[rownames(tax) %in% "fASV_27"] <- f_ASV27 
tax[rownames(tax) %in% "fASV_80"] <- f_ASV80
tax[rownames(tax) %in% "fASV_81"] <- f_ASV81
tax[rownames(tax) %in% "fASV_95"] <- f_ASV95
tax[rownames(tax) %in% "fASV_146"] <- f_ASV146

#Finally, replace taxonomy table in the ps object 
tax_table(ps_ITS) <- tax

#clean
rm(number, ps_phylum, ps_sel, x, f_ASV1, f_ASV27, f_ASV80, f_ASV81, f_ASV95,f_ASV146,
   tax,ASV_sel,Phylum_NA)

```


## Adding FunGuild
Following: https://readingradio.github.io/J.nigra.Rmds/soilfunguild_jnigra17_fa19_ajo.html

```{r}

#First, let's subset our ps object to the first 50 ASVs as a test
top50 <- names(sort(taxa_sums(ps_ITS), decreasing = TRUE)[1:50])
ps_ITS50 <- subset_taxa(ps_ITS, ASV %in% top50) #ok

#first check the format of the OTU table
#rows should be taxa names and columns sample names
head(otu_table(ps_ITS50)) #ok
otu <- as.data.frame(otu_table(ps_ITS50))
head(otu)

#Then check the taxonomy table
head(tax_table(ps_ITS50)) #rows are ASVs and tax information is columns, ok
tax <- as.data.frame(tax_table(ps_ITS50))
tax <- tax[,-8:-9] #let's delete the confidence column and ASV for now
colnames_tax <- colnames(tax)

#make a new df in which everything is in a single column
#https://www.r-bloggers.com/2022/07/convert-multiple-columns-into-a-single-column-tidyr-part4/
taxonomy <- tax %>% 
            select(all_of(colnames_tax))%>%
            unite(col="taxonomy", sep=';')

#now I need to add this taxonomy column to the otu table 
otu_table_top50 <- cbind(otu, taxonomy)
otu_table_top50$OTU_ID <- rownames(otu_table_top50)

otu_table_top50 <- otu_table_top50 %>% 
                   relocate(OTU_ID) #place it in column 1

#save it as a table
write.table(otu_table_top50, "amplicon_data/FunGuild/otu_table_top50.txt",
            sep="\t",
            row.names=FALSE,
            col.names = TRUE,
            quote = FALSE)

```

After running it in the shell terminal with the python script, let's see what we've got

```{r}

guild_table <-read.delim("amplicon_data/FunGuild/otu_table_top50.guilds.txt",
                         header=TRUE,
                         sep="\t",
                         fill=TRUE,
                         strip.white=TRUE)

#looks good! now, let's do this but with the full ITS phyloseq

```

With the full ps

```{r}

#first check the format of the OTU table
#rows should be taxa names and columns sample names
head(otu_table(ps_ITS)) #ok
otu <- as.data.frame(otu_table(ps_ITS))
head(otu)

#Then check the taxonomy table
head(tax_table(ps_ITS)) #rows are ASVs and tax information is columns, ok
tax <- as.data.frame(tax_table(ps_ITS))
tax <- tax[,-8:-9] #let's delete the confidence column and ASV for now
colnames_tax <- colnames(tax)

#make a new df in which everything is in a single column
#https://www.r-bloggers.com/2022/07/convert-multiple-columns-into-a-single-column-tidyr-part4/
taxonomy <- tax %>% 
            select(all_of(colnames_tax))%>%
            unite(col="taxonomy", sep=';')

#now I need to add this taxonomy column to the otu table 
otu_table_ITS <- cbind(otu, taxonomy)
otu_table_ITS$OTU_ID <- rownames(otu_table_ITS)

otu_table_ITS <- otu_table_ITS %>% 
                 relocate(OTU_ID) #place it in column 1

#save it as a table
write.table(otu_table_ITS, "amplicon_data/FunGuild/otu_table_ITS.txt",
            sep="\t",
            row.names=FALSE,
            col.names = TRUE,
            quote = FALSE)

```

After running it in the shell terminal with the python script (following https://github.com/UMNFuN/FUNGuild), let's see what we've got:

```{r}

guild_table_full <-read.delim("amplicon_data/FunGuild/otu_table_ITS.guilds.txt",
                         header=TRUE,
                         sep="\t",
                         fill=TRUE,
                         strip.white=TRUE)

#keep only those with information (last 10 columns)
guild_table_full <- guild_table_full[ , c(1, 147:156)]

#save it 
write.csv(guild_table_full, "amplicon_data/FunGuild/otu_table_ITS.guilds.csv")

#check
unique(guild_table_full$Trophic.Mode) #9 different ones 
unique(guild_table_full$Guild) #163 different ones 

guild <- as.data.frame(guild_table_full)
guild <- guild %>%
        select(-c(Citation.Source, taxonomy, Notes)) #let's remove these columns because annoying

colnames(guild)[1] <- "ASV" #change it to ASV to merge it

#make df again of taxonomy
tax <- as.data.frame(tax_table(ps_ITS))

#merge
tax_guild <- left_join(tax, guild, by="ASV") #ok
rownames(tax_guild) <- tax_guild$ASV

tax_guild <- as.matrix(tax_guild)

#put it back to ps
tax_table(ps_ITS) <- tax_guild #done!

```

### Filtering By sample reads & non-informative ASVs

First, by full ps
```{r}

ps_ITS

#remove blanks
ps_ITS <- subset_samples(ps_ITS, sample_or_blank != "blank") 

#Filtering by number of reads

#quickly check on the number of reads 
sort(sample_sums(ps_ITS))
plot(sort(sample_sums(ps_ITS))) #lot's with very few reads 

#remove samples with low number of reads, removing those with less than 10,000 reads
ps_ITS <- subset_samples(ps_ITS, libsize_after_nonFungi > 10000) 

#check number of reads 
plot(sort(sample_sums(ps_ITS))) #looks a bit better, but still there are two samples with too low reads

#check final sequence lenght. ITS sequences smaller than 100bp should be discarded
summary(ps_ITS@refseq@ranges@width)  
sort(ps_ITS@refseq@ranges@width)

ps_ITS<- prune_taxa(taxa = as.data.frame(refseq(ps_ITS)@ranges)$width>100,
                       x = ps_ITS) #1 ASVs removed

#remove those ASVs which now have 0 reads (after removing samples)
ps_ITS <- prune_taxa(taxa_sums(ps_ITS ) >0, ps_ITS) #2,278 ASVs

#add new library size after filtering
ps_ITS@sam_data$libsize_after_filtering <- sample_sums(ps_ITS)
plot(sort(ps_ITS@sam_data$libsize_after_filtering))

#make new column with the percentage of how many reads were kept 
ps_ITS@sam_data$pct_reads_kept <- ((ps_ITS@sam_data$libsize_after_filtering/ps_ITS@sam_data$total_reads)*100)

plot(sort(ps_ITS@sam_data$pct_reads_kept)) #lowest is 63%


#get summary info per experiment
reads_summary.f <- ps_ITS@sam_data %>% 
                 data.frame() %>% 
                 group_by(Experiment)%>%
                 summarise(reads_per_sample = mean(libsize_after_filtering),
                           stdev=sd(libsize_after_filtering),
                           reads_kept_perc= mean(pct_reads_kept),
                           stdev_perc=sd(pct_reads_kept),
                           n=n())

#get summary info per treatment & experiment
reads_summary.f.t <- ps_ITS@sam_data %>% 
                    data.frame() %>% 
                    group_by(Experiment, plant_pathway_induced)%>%
                    summarise(reads_per_sample = mean(libsize_after_filtering),
                           stdev=sd(libsize_after_filtering),
                           reads_kept_perc= mean(pct_reads_kept),
                           stdev_perc=sd(pct_reads_kept),
                           n=n())


#save ps_ITS finally
save(ps_ITS, file = "./amplicon_data/Phyloseq_objects/ps_ITS.RData")

```

Now, split by experiment as for bacteria
```{r}

#as they come from independent experiments, separate them to filter them independently
ps_ITS_split <- phyloseq_sep_variable(ps_ITS, variable="Experiment", drop_zeroes = T)

ps_Phyto <- phyloseq_sep_variable(ps_ITS_split$cond_phytohormones, variable=c("plant_pathway_induced"), drop_zeroes = T)

#plot histograms
lapply(ps_ITS_split, function(ps){
  hist(ps@sam_data$pct_reads_kept)})

#save it
save(ps_ITS_split, file = "./amplicon_data/Phyloseq_objects/ps_ITS_split.RData")
```

Visualize it
```{r}
#make it a df to plot it 
df_ITS <- data.frame(sample_data(ps_ITS))
order_harvestID <- df_ITS$Harvest_ID

#make Harvest ID a factor to have a better plot
df_ITS$Harvest_ID <- factor(df_ITS$Harvest_ID, levels=order_harvestID)

#see it 
ggplot(df_ITS, aes(pct_reads_kept, Harvest_ID, label = Harvest_ID)) +    
  geom_point(aes(colour = Experiment)) +
  geom_text(aes(label = Harvest_ID), hjust = - 0.5)+
  facet_wrap(~Experiment)

ggsave("Fun.percentage_reads_kept.png", path = "./Plots/00_amplicon_preprocessing/",
         width = 40, height = 20 , units = "in", dpi=300, scale=0.3)


#make paired plot
#first make df 
df_reads <- subset(df_ITS, 
                   select= c("Harvest_ID", "Experiment", "total_reads", "libsize_after_nonFungi", "libsize_after_filtering"))

df_reads_long <- df_reads %>% 
                 pivot_longer(!c(Harvest_ID,Experiment), names_to = "Steps",
                         values_to = "number_of_reads")

df_reads_long$Steps <- factor(df_reads_long$Steps, 
                   levels= c("total_reads", "libsize_after_nonFungi",
                             "libsize_after_filtering"))

#plot it
ggplot(df_reads_long, aes(x=Steps, y=number_of_reads))+
  geom_boxplot(aes(fill=Steps), alpha=0.2)+
  geom_line(aes(group = Harvest_ID)) + 
  geom_point(size = 2)+  
  geom_label(aes(label= Harvest_ID), size=2.5)+
  facet_wrap(~Experiment)

ggsave("Fun.summary_reads-after-filteringsteps.png", path = "./Plots/00_amplicon_preprocessing/",
         width = 40, height = 20 , units = "in", dpi=300, scale=0.3)

#clean
rm(df_reads, df_reads_long)

```

```{r}

#see what's there 
plot_Fun <- plot_bar(ps_ITS, fill= "Phylum")
plot_Fun <- plot_Fun + facet_wrap(~Experiment, nrow=1, scales="free_x")

ggsave("Fun.final_phylum.png", path = "./Plots/00_amplicon_preprocessing/",
         width = 40, height = 20 , units = "in", dpi=300, scale=0.3)

#few ASVs with high abundance and no classification in Phylum

#clean
rm(plot_Fun)

#clean
#clean
rm.all.but(keep=c("ps_16S", "ps_16S_split", "ps_ITS", "ps_ITS_split"), keep_functions = TRUE)

```

#Summary
